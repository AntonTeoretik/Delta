# Лекция 8. Монады.

# Что такое Монада.
## Стрелки Клейсли.

Монада -- класс типов, который так же, как и функтор принимает не просто тип, а однопараметрический тип. Идея монад состоит в том, чтобы уметь накапливать некоторые вычислительные эффекты. Для начала посмотрим, какие функции могут обладать такими эффектами:

```Haskell

f :: a -> Maybe b         -- может завершиться неудачей
f :: a -> b               -- может возвратиться много результатов
f :: a -> (Either s) b    -- могут завершаться с типизированным исключением
f :: a -> (s, b)          -- могут делать записи в лог
f :: a -> ((->) e) b      -- читаем из внешнего окружения
f :: a -> (State s) b     -- изменяемое состояние
f :: a -> IO b            -- ввод/вывод, работает с файлами

```

Все эти функции описываются общей схемой: 
```Haskell

f :: a -> m b

```

Такие функции называются *стрелками Клейсли*.

## Определение монады

```Haskell

infixl 1 >>=

class Monad (m :: * -> *) where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b   -- bind
  (>>) :: m a -> m b -> m b
  fail :: String -> m a
  {-# MINIMAL (>>=) #-}


```

### `return`

`return` это функция, которая должна тривиальным образом упаковывать значение типа `a` в монаду `m`. 


```Haskell

>> return True :: [Bool]
[True]

>> return True :: Maybe Bool
Just True

>> return True :: IO Bool
True -- вывод в консоль!

```


### Оператор `>>=`

Это **Очень Важный Оператор**

Он позволяет выполнить цепочку вычислений так, чтобы мог накапливаться некоторый эффект. Основная концепция -- принять упакованный элемент, 
распоковать его, применить стрелку Клейсли, учесть предыдущие эффекты.

Посмотрим на тип:

```Haskell
(>>=) :: m a -> (a -> m b) -> m b

```

По сигнатуре этот оператор похож на оператор `&` (перевернутый доллар):
```Haskell

>> import Data.Function
>> :i (&)
(&) :: a -> (a -> b) -> b       -- Defined in ‘Data.Function’
infixl 1 &

--- примеры цепочки вычислений:

>> (+3) $ (*2) $ floor 2.4
7

>> 2.4 & floor & (*2) & (+3)
7

```

Оператор `>>=` позволяет делать такие же цепочки вычислений, при этом сохраняя эффект от вычислений!

Ещё одна похожая вещь -- тип оператора `>>=` похож на тип функции `fmap` c переставленными аргументами:

```Haskell

>> :t flip fmap 
flip fmap :: Functor f => f a -> (a ->   b) -> f b

>> :t (>>=)
(>>=)     :: Monad m   => m a -> (a -> m b) -> m b


```

В отличие от `fmap`, `>>=` может менять структуру контейнера.


### `>>` и `fail`

```Haskell

(>>) :: m a -> m b -> m b
-- x >> y = x >>= \_ -> y -- облегченное связывание, игнорирует a, но сохраняет эффекты.  

fail :: String -> m a
fali s = error s


```


### Ещё полезные функции:

```Haskell

(=<<) :: Monad m => (a -> m b) -> m a -> m b
(=<<) = flip (>>=)


(<=<) :: Monad m = (b -> m c) -> (a -> m b) -> (a -> m c)
f <=< g = \x -> g x >>= f


```

## Монада `Identity` и три закона монад.


```Haskell

newtype Identity a = Identity {runIdentity :: a}
  -- newtype это почти то же, что и data.

```

Представляет собой просто коробку, в которой лежит тип `a`. Доступ к внутреннему значению -- `runIdentity`.

Этот тип однопараметричен, поэтому можно сделать его монадой (тривиальной):

```Haskell

instance Monad Identity where
  return x = Identity x
  (Identity x) >>= f = f x 

```

Нужен только для того, чтобы посмотреть на то, как работают монады.

Пример:

```Haskell

kleislyMul2 :: Integer -> Identity Integer
kleislyMul2 x = Identity (2 * x)


>> kleislyMul2 5
Identity {runIdentity = 5} -- нужно вытащить значения.

>> runIdentity $ kleislyMul2 5
5


-- используем bind
>> runIdentity $ kleislyMul2 5 >>= kleislyMul2 >>= kleislyMul2
40

-- это похоже на это:
>> 5 & (*2) & (*2) & (*2)
40


```

Для того, чтобы вынести аргумент в начало можно использовать `return`!


```Haskell

-- используем bind
>> runIdentity $ return 5 >>= kleislyMul2 >>= kleislyMul2 >>= kleislyMul2
40

```

Получаем следующее свойство:

```Haskell

return 5 >>= kleislyMul2  == kleislyMul2 5 

```

Получаем **первый закон монад**:

```Haskell

return a >>= k  =  k a

```

Получается, что `return` является "левой единицей" с точки зрения монадических вычислений. 

Аналогично эта функция должна быть правой единицей:

```Haskell

kleislyMul2 5 >>= return  == kleislyMul2 5

```

В общей ситуации это называется **вторым законов монад**:

```Haskell

m >>= return  ==  m

```


Третий закон должен выражать ассоциативность. Хотелось бы написать что-то такое:

```Haskell

(m >>= k) >>= k' == m >>= (k >>= k') -- не проходит по типам.

```

Нужно совершить махинации:

Выражение `(k >>= k')` должно превратиться в стрелку Клейсли, поэтому пишем аргумент:

```Haskell

(m >>= k) >>= k' == m >>= (\x -> k x >>= k')

```

Это называется **третьим законом монад**.


Пример как его использовать:

```Haskell

runIdentity $ kleislyMul2 5 >>= (\x -> kleislyMul2 x >>= ( \y -> kleislyMul2 y))


```

## Ещё раз три закона монад:

```Haskell
return a >>= k == k a                         -- первый закон монад

m >>= return  =  m                            -- второй закон монад

(m >>= k) >>= k' == m >>= (\x -> k x >>= k')  -- третий закон монад

```


## `do`-нотация

Запишем нашу цепочку в функцию:

```Haskell

goWrap0 = 
  kleislyMul2 5 >>=
  kleislyMul2 >>=
  kleislyMul2 >>=
  return -- это ничего не меняет


goWrap1 = 
  kleislyMul2 5 >>= (\x -> 
  kleislyMul2 x >>= (\y -> 
  kleislyMul2 y >>= (\z ->
  return z)))

-- область переменной!
-- теперь поменяем return

goWrap2 = 
  kleislyMul2 5 >>= (\x ->  -- x := 5 ;
  kleislyMul2 x >>= (\y ->  -- y := x * 2 ;
  kleislyMul2 y >>= (\z ->  -- z := y * 2 ;
  return (x, y, z))))       -- return (x, y, z)

-- перегружаем точку с запятой!

-- теперь хотим облегченное выражение


goWrap3 = 
  kleislyMul2 5 >>= (\x ->  -- x := 5 ;
  kleislyMul2 x >>= (\y ->  -- y := x * 2 ;
  kleislyMul2 y >>          -- y * 2 ; ничего не делает (но может сделать эффект)
  return (x, y)))           -- return (x, y)

```

Теперь хочется сделать удобный синтаксис:

```Haskell

do {e1; e2}         =  e1 >> e2 

do {p <- e1; e2}    =  e1 >>= \p -> e2

do {let v = e1; e2} =  let v = e1 in do e2           

```

Удобная версия:

```Haskell

goWrap4 = 
  let i = 5 in              -- i := 5
  kleislyMul2 i >>= (\x ->  -- x := i ;
  kleislyMul2 x >>= (\y ->  -- y := x * 2 ;
  kleislyMul2 y >>          -- y * 2 ; 
  return (i, x+y)))         -- return (i, x+y)


goWrap5 = do  -- новое слово
  let i = 5              
  x <- kleislyMul2 i 
  y <- kleislyMul2 x
  kleislyMul2 y
  return (i, x+y)

-- тут два присваивания!
-- каждая строчка в одной и той же монаде!

-- fail работает если возвращается что-то страшное!

```

## Функторы и монады.

Любай монада является функтором!

Если `MyType` -- монада, то можно сделать её функтором таким образом:

```Haskell

instance Functor MyType where
  fmap f x = x >>= (return . f)

```





