# Лекция 7, собственные классы типов, instance. Функторы.

# Собственные классы типов и instance

В Haskell можно создавать собственные классы типов. Для этого нужно указать название и список функций, которые для этого класса типов должны быть определены. 

Часто, после этого добавляют необходимые аксиомы, которым должны удовлетворять эти функции, однако Haskell не умеет отслеживать выполнение аксиом, поэтому их выполнение остается на совесть программисту. Давайте создадим класс `Group`, который реализует идею математической группы -- т.е. множества с одной обратимой ассоциативной операцией и нейтральным элементом. 

```Haskell

infixl 5 #
class Group a where
  (#) :: a -> a -> a -- это наша операция.
  invert  :: a -> a   -- для каждого элемента можно вернуть обратный.
  neutral :: a        -- нейтральный элемент.

-- Аксиомы группы
-- (#) ассоциативна -- x # y # z = (x # y) # z = x # (y # z),
-- neutral # x == x
-- x # neutral == x
-- x # (invert x) == neutral
-- (invert x) # x == neutral

```

Для того, чтобы сделать какой-либо тип представителем класса `Grouph` надо написать ключевое слово `instance`, далее название нашего класса типов и названия того типа, который мы хотим реализовать. Пример -- `Integer` является группой по сложению:

```Haskell

instance Group Integer where
  neutral = 0
  invert = negate
  (#) = (+)

--
>> 1 *. 4
5
>> invert 4
-4
>> neutral :: Integer
0

```

Можно реализовать тривиальную группу из одного элемента, т.е. реализовать для типа `()`

```Haskell

instance Group () where
  neutral = ()
  invert = id
  () # () = ()

--
>> () # ()
()
>> invert ()
()
>> neutral :: ()
()

```

Ещё один вариант -- можно сделать представителя класса типов с контекстом! Например, если у нас есть типы `a` и `b`, которые являются представителями класса типов `Group`, то можно тип `(a, b)` сделать представителем это класса:

```Haskell

instance (Group a, Group b) => Group (a, b) where
  (x1, y1) # (x2, y2) = (x1 # x2, y1 # y2)
  invert (x1, y1) = (invert x1, invert y1)
  neutral = (neutral, neutral)

```

Обратите внимание, что, например, `invert` в левой части и `invert` в реализации вызываются от разных типов, в частности `invert x1, invert y1` определены, так как `x1, y1` относятся к классу типов `Group`.

Можно реализовывать представителей для встроенных классов типов. Например, допустим, у нас есть тип `Complex`, реализующий комплексные числа. Мы хотим сделать его представителем класса типов `Num` и `Show`, т.е. уметь складывать, вычитать и умножать комплексные числа, а также показывать их в консоль.

Сделаем это так:


```Haskell

data Complex = Complex Double Double
  deriving (Eq)

instance Show Complex where
  show (Complex x y) = show x ++ (if y >= 0 then " + i*" else " - i*") ++ show (abs y) -- реализация красивого Show для комплексных чисел.


instance Num Complex where
  (+) (Complex x1 y1) (Complex x2 y2) = Complex (x1 + x2) (y1 + y2)
  negate (Complex x y) = Complex (-x) (-y)
  (*) (Complex x1 y1) (Complex x2 y2) = Complex (x1 * x2 - y1 * y2) (x1 * y2 + x2* y1 ) 
  abs x = x -- это приходится реализовывать как-то, у нас -- бессмысленно.
  signum x = 1 -- аналогичено
  fromInteger n = Complex (fromInteger n) 0 

---

>> Complex (-1) 2 + Complex 2 (-1)
1.0 + i*1.0
>> Complex (-1) (-2) * Complex 2 (-1)
-4.0 - i*3.0
>> fromInteger 2 :: Complex 
2.0 + i*0.0



```

Можно также реализовать деление комплексных чисел. В этом случае надо еще сделать тип `Complex` представителем типа `Fractional`:

```Haskell

instance Fractional Complex where
  (/) z (Complex x2 y2) = alpha * z * Complex x2 (negate y2)
    where
      alpha = ( fromRational . toRational . (1/) $ x2^2 + y2^2)  ::Complex
  fromRational x = Complex (fromRational x) 0 

>> let i = Complex 0 1
>> i / i
1.0 + i*0.0
>> i * i
-1.0 + i*0.0

```

## Уравнения в классах типах: 

```Haskell

class Eq a where
  (==), (/=) :: a -> a -> Bool
  x /= y = not (x == y)
  x == y = not (x /= y) 


instance Eq Bool where
  True == True = True
  False == False = True
  _ == _  = False


```

## Стрелка как конструктор типа!

```Haskell

>> :k (->)
(->) :: * -> * -> *

>> :i (->)

data (->) (a :: TYPE q) (b :: TYPE r)
```

Получаем, что стрелка является двух параметрическим типом, в частости можно сделать так:

```Haskell
>> not :: (->) Bool Bool  -- строим префиксную форму типа.
not :: (->) Bool Bool :: Bool -> Bool
```

# Functor

Класс типов `Functor` работает с однопараметрическими типами, т.е. если мы хотим сделать `instance Functor t`, то `kind` типа `t` должен быть такой: `* -> *`.
Для такий типов требуется определить только одну функцию -- `fmap`

```Haskell

class Functor t where
  fmap :: (a -> b) -> t a -> t b

```

Тут стоит обратить внимание, что раз `t :: * -> *` , то `t` не является еще типом, а вот `t a` уже является. Таким образом, функция `fmap` "поднимает" данную функцию `a -> b` до функции типа `t a -> t b`. Делаться это должно максимально тривиальным способом. Рассмотрим на примерах:

* Самый простой однопараметрический тип -- это тип списка. Функция `fmap` в этом случае должна иметь такой тип:

```Haskell
 fmap :: (a -> b) -> [a] -> [b]
```

Тип этой функции в точности совпадает с типом функции `map`! Действительно, в данном случае это и будет правильной реализацией:

```Haskell
 >> fmap (== 2) [1,2,3]
 [False, True, False]
```

* Другой однопараметрический тип, который нам знаком -- это тип `Maybe`. Функция `fmap` для него будет иметь такой тип:

```Haskell
 fmap :: (a -> b) -> Maybe a -> Maybe b
```

Самый простой способ, которым можно определить такую функцию -- следующий:

```Haskell
 fmap f (Just x) = Just $ f a
 fmap _ Nothing  = Nothing
```

Т.е. наша функция "протаскивает" сквозь `Just` функцию аргумент, а если передан `Nothing`, то ничего с ним не делает. Это удобно для того чтобы работать с функциями, которые могут вернуть ошибку: вместо того, чтобы перебирать случаи, можно использовать `fmap`.

* Неожиданный одно параметрический тип -- это функция, у которой фиксирован первый аргумент! Действительно,

```Haskell
>> :k (->) Bool
(->) Bool :: * -> *

```
Пусть тип `e` фиксирован и мы хотим сделать функциональный тип `e -> c` представителем класса `Functor`. Тогда `fmap` должен будет иметь такой тип:

```Haskell
 fmap :: (a -> b) -> (e -> a) -> (e -> b)
```

Мы видим, что это такой же тип, как и у композиции функций! Действительно:

```Haskell

>> fmap length tail "ABC"
3

```
## Законы

Для того, чтобы `fmap` была корректно определена, должны выполняться следующие законы:

```Haskell

fmap id = id
fmap (f . g) = fmap f . fmap f

```
