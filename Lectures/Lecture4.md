
# Лекция 4 -- Типы и классы типов

# Полиморфизм

В Haskell многие функции имеют **полиморфный** тип. Это означает, что в качестве аргументов они могут принимать или возвращать произвольный тип.
Полиморфизм бывает **параметрическим** и **специальным**.

**Параметрические полиморфизм** -- это тот случай, когда функция работает одинаково вне зависимости от типа аргумента. 

Пример: функция `id :: a -> a` принимает аргумент произвольного типа `a` и возвращает его самого. Реализация этой функции не зависит от типа!
Из знакомых нам функций параметрически полиморфны функции:

* `const :: a -> b -> a`, возвращающая свой первый аргумент, 
* `($) :: (a -> b) -> a -> b`, которая применяет функцию `(a -> b)` к своему второму аргументу типа `a`,
* `(.) :: (b -> c) -> (a -> b) -> a -> c` -- композиция функций,
* `fst :: (a, b) -> a `,
* `snd :: (a, b) -> b `,
* ...

```haskell
    >> :t id
    id :: a -> a

    >> id False
    False

    >> id 4
    4

    >> fst (False, (+5))
    False
```

**Специальный полиморфизм** -- тот случай, когда функция может принять разные (но уже не любые) типы, но в зависимости от типа реализация будет разной. Пример:

* `+, -, *, /, **, ^, ...` -- все арифметические операции по разному работают с разными типами. Например `+` работает по разному с разными числами: реализация для `Double`, `Int`, `Integer` внутри компьютера будет совершенно разной.

* `==, \=` -- несмотря на то, что эти операции достаточно тивиальны, для разных типов требуется разная реализация. Например, для того чтобы сравнить списки, требуется сравнить длину списков и каждый элемент в отдельности. Реализация для сравнения обычных чисел, конечно, не требует такой работы.

* `>, <` -- аналогично предыдущему, сравнение чисел и сравнение, например, кортежей требуют разной реализации.

* `show` -- реализация функции `show` может быть совершенно разная для разных типов! 

Для всех этих функций реализация по существу использует структуру того типа, который подаётся на вход.

Давайте посмотрим на типы соответствующих функций:


```haskell
    >> :t (+)
    (+) :: Num a => a -> a -> a

    >> :t (/=)
    (/=) :: Eq a => a -> a -> Bool

    >> :t (>)
    (>) :: Ord a => a -> a -> Bool

    >> :t (^)
    (^) :: (Integral b, Num a) => a -> b -> a
    -- C Num мы уже встречались, а с Integral ещё нет -- вкратце это те типы, которые обладают структурой целых чисел. 
    -- Любой тип из класса типов Inegral может быть приведен к Integer с помощью функции toInteger.


    >> :t show
    show :: Show a => a -> String
    -- напоминаем, что String и [Char] -- это одно и то же
```

В типе каждой из них присутствует так называемый **контекст** -- выражение до знака `=>`. Для `(+)` контекстом является выражение `Num a`, для `(/=)` контекстом является выражение `Eq a` и т.д. Как уже было сказано ранее, выражение `Num a` означает, что для того, чтобы эта функция работала, тип `a` _обязан_ принадлежать классу типов `Num`. Например, в случае оператора возведения в целочисленную степень `^`, мы видим, что тип второго аргумента обязан принадлежать классу типов `Integral`, а тип первого аргумента должен принадлежать типу `Num`.

Осталось понять, что же такое класс типов.

# Классы типов

Класс типов -- это что-то наподобие списка требований, которые предъявляются всем тем типам, которые хотят быть представителями данного класса типов. Этот список выглядит как набор функций, которые должны быть для этого типа определены. Для того чтобы понять, что за список функций требует конкретный класс типов, можно использовать в ghci команду `:info` (или сокращённо `:i`). Рассмотрим на примере класс типов `Eq`:

```haskell
    >> :i Eq
    
    class Eq a where
      (==) :: a -> a -> Bool
      (/=) :: a -> a -> Bool
      {-# MINIMAL (==) | (/=) #-}

    -- Defined in ‘GHC.Classes’
    instance (Eq a, Eq b) => Eq (Either a b)
    -- Defined in ‘Data.Either’
    instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’
    instance Eq a => Eq [a] -- Defined in ‘GHC.Classes’
    instance Eq Word -- Defined in ‘GHC.Classes’
    instance Eq Ordering -- Defined in ‘GHC.Classes’
    instance Eq Int -- Defined in ‘GHC.Classes’
    instance Eq Float -- Defined in ‘GHC.Classes’
    instance Eq Double -- Defined in ‘GHC.Classes’
    instance Eq Char -- Defined in ‘GHC.Classes’
    instance Eq Bool -- Defined in ‘GHC.Classes’
    ...
```

Поймём, что это значит:

Сначала идёт описание класса типов `Eq` -- его название и список тех функций, которые должны быть определены для каждого типа, который хочет быть представителем этого класса типов:

```haskell
    class Eq a where                    -- это объявление класса типов. Здесь говорится, что он будет называться Eq

      (==) :: a -> a -> Bool            -- спискок фукнций -- здесь их всего две штуки -- (==) и (/=)
      (/=) :: a -> a -> Bool

    ...
```

Дальше идёт комментарий -- `{-# MINIMAL (==) | (/=) #-}`. Подробно говорить про это пока не будем, но тут написано, что пользователю, желающему создать свой собственный тип, который был бы представителем `Eq`, не обязательно реализовывать и функцию `==`, и функцию `/=`, он может реализовать только одну из них (вторая выведется автоматически!). 

Последнее, что идёт -- это список **представителей** (**instance**) этого класса типов. В частности, мы видим, что `Int`, `Float` и другие привычные нам типы являются представителями `Eq`, поэтому мы можем писать выражения вида `2 == 4`.


Заметим, что некоторые классы типов имеют свой собственный контекст: посмотрим на класс типов `Ord`:

```haskell
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  {-# MINIMAL compare | (<=) #-}

  ...

```

В данном примере для того чтобы тип `a` был представителем класса `Ord`, *необходимо*, чтобы он уже был представителем `Eq`.
Также говорится, что, для того чтобы тип `a` был представителем класса `Ord`, для него должны быть реализованы функции `compare`, `<`, `>`, и т.д.
Заметим, что как и в прошлый раз, пользователю не обязательно реализовывать вручную все эти функции: достаточно лишь реализовать оператор `<=`, а остальные выведутся сами. Но, если по каким-то причинам пользователь хочет самостоятельно определить все эти функции (например, из соображения эффективности), то он может это сделать.


Почему мы никогда сами не указывали контекст при объявлении функции? Дело в том, что Haskell умеет самостоятельно выводить ограничения на типы. Рассмотрим пример:

```Haskell
  myFunc x y = y + max x x  -- max x x не очень осмысленная величина, но пусть будет
```

Попробуем самостоятельно вывести тип этой функции: 

* Мы видим, что это функция двух аргументов. Самый общий вариант для такой функции -- это `myFunc :: a -> b -> c `.
* Заметим, что в выражении используется функция `max`, которая имеет тип `max :: Ord t => t -> t -> t`. Значит, на первый аргумент накладывается контекст `Ord a`. Наша функция становится типа `myFunc :: Ord a => a -> b -> c`.
* Затем заметим, что `max x x` имеет тип `a`, и мы складываем его со вторым аргументом. 
Оператор `+` имеет тип `(+) :: Num t => t -> t -> t`, а значит, отсюда следуют две вещи: во-первых, это то, что `a` и `b` -- просто один и тот же тип, во-вторых, на них есть ограничение `Num`. 
Значит, от типа `b` мы избавились, и наша функция приобретает такой тип: 
`myFunc :: (Ord a, Num a) => a -> a -> c`.
* Наконец, мы видим, что полученное выражение типа `a` -- это то самое выражение, которое мы должны вернуть. А значит, `c` -- это тот же тип, что и `a`!

Итого, окончательный тип нашей функции: `myFunc :: (Ord a, Num a) => a -> a -> a`

Действительно:


```Haskell
  >> :t myFunc
  myFunc :: (Num a, Ord a) => a -> a -> a

```

# Типы

В этой части мы наконец научимся строить собственные типы данных!

## Перечисления

Что такой тип? С точки зрения Haskell тип -- это множество значений. Каждый тип в Haskell имеет название и множество констант, которые принадлежат этому типу.

Рассмотрим пример: тип `Bool` населяют две константы: `True` и `False`. Таким образом, `Bool = {True, False}`.
Другой пример: тип `Integer`, который населяет бесконечное количество значений `..., -2, -1, 0, 1, 2, ...`. Таким образом, `Integer = {..., -2, -1, 0, 1, 2, ...}`. 

Построить свой тип, значит, указать все константы, которые принадлежат этому типу (в случае бесконечного количества значений мы, конечно, будем работать немного по-другому). Допустим, мы хотим создать тип `Color`, который содержит три значения: `Red`, `Green`, `Blue`.

В Haskell это делается с помощью следующего синтаксиса: `data НАЗВАНИЕ_ТИПА = ЗНАЧЕНИЕ_1 | ЗНАЧЕНИЕ_2 | ... | ЗНАЧЕНИЕ_N"`. Заметим, что название типа и название значений *должны начинаться с **большой** буквы*.

```Haskell
  data Color = Red | Green | Blue
```

Мы получили полноценный тип, содержащий три значения.

Немного терминологии. 
`Color` -- это **конструктор типа**. Слова `Red, Green, Blue` -- это **конструкторы данных**. Что это значит, будет показано позже.

Теперь мы можем создавать функции, которые принимают тип, который мы реализовали. В частности, мы можем использовать механизм сопоставления с образцом, для того чтобы реализовывать разное поведение для разных констант. Например:

```Haskell
  getColorCode :: Color -> String
  getColorCode Red = "#ff0000"
  getColorCode Green = "#00ff00"
  getColorCode Blue = "#0000ff"

  
  colorFromCode :: String -> Color
  colorFromCode "#ff0000" = Red
  colorFromCode "#00ff00" = Green
  colorFromCode "#0000ff" = Blue
  colorFromCode _ = error "There is no color for that code"

  ---

  >> getColorCode Red
  "#ff0000"

  >> colorFromCode "#0000ff"
  <interactive>:101:1: error:
    • No instance for (Show Color) arising from a use of ‘print’
    • In a stmt of an interactive GHCi command: print it

```

Мы видим, что вторая функция сломалась. Почему? Потому что мы не умеем выводить в консоль константы нашего типа, так ка для этого тип должен быть представителем класса типов `Show`. К счастью, для таких простых классов типов существует автоматическая доставка функций. Для этого можно использовать ключевое слово `deriving`:


```Haskell
  data Color = Red | Green | Blue
    deriving (Show, Eq)
```

Мы добавили автоматическую реализацию классов типов `Show` и `Eq`. Теперь мы можем писать выражения вида `Red == Green` и получать ожидаемый результат `False`, а также выводить в консоль значения данного типа:

```Haskell
  >> colorFromCode "#0000ff"
  Blue

  >> Red
  Red

  >> Red == Blue
  False

```

## Произведения типов

Конечно же, если бы единственным способом, которым мы бы могли образовывать типы, было бы перечисление констант, было бы очень грустно и уныло. К счастью, существует ещё одна возможность -- построение **произведения** типов. Дело в том, что мы можем сделать так, чтобы конструктор данных имел аргументы. Посмотрим, где это бывает нужно. Допустим, мы хотим сделать тип `Complex`, представляющий собой комплексное число вида `a + bi`. Число имеет два аргумента (пусть, для определенности, типа `Double`). Для того чтобы реализовать такой тип, напишем следующее:

```Haskell
data Complex = Comp Double Double
  derivng (Show, Eq) -- эта строчка до сих пор хорошо работает
```

В данном случае тип `Complex` имеет один конструтор данных под названием `Comp`, который имеет два аргумента типа `Double`. Теперь мы можем создать комплексное число:

```Haskell
>> Comp 3 4
Comp 3.0 4.0

>> :t Comp 3 4
Comp 3 4 :: Complex
```

Замечание: строчка `Comp 3 4` очень похожа на вызов функции двух аргументов. И это так!

```Haskell 
>> :t Comp
Comp :: Double -> Double -> Complex

```

Т.е. конструкторы данных являются настоящими функциями, которые строят данные нашего типа!

Второе замечание --  тип, образованный с помощью других типов, называется **произведением типов**.

Третье замечание **надо запомнить** -- теперь значения типа `Complex` **всегда** выглядят следующим образом: `Comp x y`. Это обязательно учитывать при написании функций. 

Четвертое замечание -- если конструтор данных всего один, принято называть его так же, как и сам тип. Это не приводит ни к каким ужасным последствиям. В нашем примере лучше это сделать:

```Haskell
data Complex = Complex Double Double -- изменили название!
  derivng (Show, Eq) 
```

Примеры функций использующих `Complex`


```Haskell
  multiply :: Complex -> Complex -> Complex
  multiply ( Comp x1 y1 ) (Comp x2 y2 ) = Comp ( x1 * x2 - y1 * y2 ) ( x1 * y2 + x2 * y1 ) -- не забываем ставить скобочки, иначе не сработает.

  toStr :: Complex -> String
  toStr (Comp x1 y1) = show x1 ++ " + i * " ++ show y1
  
  ---

  >> toStr $ multiply (Comp 0 1) (Comp 0 1)
  "-1.0 + i * 0.0"

  --- i * i == -1

```



## Суммы произведений.

Можно совместить две парадигмы. Допустим, нам нужно построить тип `Shape`, представляющий фигуру на плоскости. Предположим, что фигуры бывают двух типов: круг и прямоугольник. У круга есть один параметр -- радиус, а у прямоугольника два -- длины сторон. Создадим такой тип:

```Haskell
data Shape = Circle Double            --- конструктор данных для круга
           | Rectangle Double Double  --- конструктор данных для прямоугольника

  derivng (Show, Eq) -- и все еще эта строчка работает хорошо
 
```


Теперь значения типа `Shape` будут выглядеть **либо** как `Circle x`, **либо** как `Rectangle x y`.


Пример, вычисляющий площадь и длину границы нашей фигуры.

```Haskell
  area :: Shape -> Double
  area (Circle r)  = pi * r * r   --- случай круга
  area (Rectangle x y) = x * y    --- случай прямоугольника 

  perimeter :: Shape -> Double
  perimeter (Circle r)  = 2 * pi * r   --- случай круга
  perimeter (Rectangle x y) = 2 * (x + y) --- случай прямоугольника


  ---

  >> area $ Circle 2  -- не забываем про то, что такое $. Это выражение эквивалентно следующему: area (Circle 2)
  12.566370614359172

  >> area $ Rectangle 2 5
  10.0

  >> perimeter (Circle 0.5)
  3.141592653589793
  
  >> perimeter (Rectangle 0.5 2)
  5.0

```
















