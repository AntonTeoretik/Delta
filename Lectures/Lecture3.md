

# Лекция 3 -- Кортежи и списки.

# Кортежи.

**Кортеж (tuple)** -- это струтура данных, которая может быть хранить несколько произвольных значений. Эти значения могут быть разных типов, поэтому у кортежа всегда фиксирована длина. Типы при этом могут быть произвольные, даже другие кортежи или функции!

Кортежи образуются с помощью круглых скобок и раделяющих запятых.



```haskell
	>> (4, 5)
	(4, 5)

	>> (20 + 2, 30 + 3)
	(22, 33)

	>> (True, 'c', 34) 
	(True, 'c', 34)
```


Заметим, что кортежа из одного элемента не существует: выражение `(4)` -- это просто значение `4`, поставленное в скобки. Однако существует кортеж из нуля элементов: `()`. 

Он очень часто применяется в тех случаях, когда возвращаемое значение функции не нужно, а нужно изменение какого-либо состояния. Но об этом мы поговорим когда будем изучать монады.

Тип у кортежа выглядит таким образом:

```haskell
	>> :t (True, False)
	(True, False) :: (Bool, Bool)

	>> :t (True, 'c', 15)
	(True, 'c', 15) :: Num c => (Bool, Char, c) 
	-- 15 has a type c, with context Num

	>> :t ( ('c', True), False )
	( ('c', True), False ) :: ((Char, Bool), Bool)
	-- tuple inside a tuple!


	>> :t ( (&&), (&& True), (True && True) )
	( (&&), (&& True), (True && True) ) 
		:: (Bool -> Bool -> Bool, Bool -> Bool, Bool)
	-- functional types!

	>> :t () 
	() :: ()
	-- type of () is it self!


```

Видно, что в кортеж можно класть функции (разных типов), а так же другие кортежи. Так же видно, что тип пустого кортежа -- это он сам, что, впрочем не мешает, потому что имена типов и имена значений никогда не пересекаются.


## Функции для работы с кортежами.
	
Кортеж из двух элементов называется парой. Для извлечения значений в Haskell существуют функции `fst` (от слова first) и `snd` (от слова second).

Их тип такой: 

```haskell
	>> :t fst
	fst :: (a, b) -> a

	>> :t snd
	snd :: (a, b) -> b

```

Примеры использования:


```haskell
	>> fst (1, True)
	1

	>> snd (1, True)
	True
```


## Кортежи и сопоставление с образцом.
Сопоставление с образцом можно делать так, чтобы извлекать значения из кортежа. Показать это проще на примере: давайте реализуем функцию `f`, которая принимает кортеж типа `(Bool, Integer, Integer)`, и возвращает сумму двух последних элементов если первый элемент `True`, а если он `False`, то возвращает `0`


```haskell
	
	f :: (Bool, Integer, Integer) -> Integer
	f (True, a, b) = a + b
	f (False, _, _) = 0


	---

	>> f (True, 5, 2)
	7
	>> f (False, 10, 3)
	0
	>> f (False, undefined, undefined)
	0
	-- here is no error because of laziness.

```

Обратите внимание, что из-за ленивости языка, в случае если	первый элемент кортежа False, то проверки двух последних аргументов не происходит! Значит там могут находиться выражения возвращающие ошибку (такое как undefined).

## Возвращение кортежей.
Кортежи используются для того чтобы возвращать несколько значений. Пример: функция `divMod` возвращает результат целочисленного деления	на число и остаток. Например, если разделить 10 на 3, то получится 3 и остаток 1. Действительно:

```Haskell
	>> divMod 10 3
	(3,1)
	-- tuple!

```

Можно написать собственную функцию, возвращающую кортеж. Для примера определим функцию, возвращающую сумму и разность двух аргументов.


```Haskell
	sumAndDiff :: (Num a) => a -> a -> (a, a)
	sumAndDiff x y = (x + y, x - y)
	
	---

	>> sumAndDiff 5 3
	(8, 2)

```


# Списки

Списки -- это тоже контейнеры, которые хранят набор данных. Отличие от кортежей -- это то, что они хранят в себе только один тип. Преимущество -- функции могут принимать списки произвольной длины.

Списки конструируются с помощью квадратных скобок. 


```Haskell
	>> [1,2,3]
	[1,2,3]

	>> [False, True]
	[False, True]

	>> ['H', 'e', 'l', 'l', 'o']
	"Hello"

```


Мы видим, что строка -- это просто список из элементов типа `Char`.

Тип списка -- это [тип элемента списка]:


```Haskell
	>> :t [True, False]
	[True, False] :: [Bool]


	>> :t ['H', 'e', 'l', 'l', 'o']
	['H', 'e', 'l', 'l', 'o'] :: [Char]

	>> :t [1, 2, 3]
	[1, 2, 3] :: Num a => [a]
	-- Потому что 1, 2, 3 имеют полиморфный тип a, с контекстом Num.

	>> :t []
	[] :: [a]

	>> :t [[True], [False, True]]
	[[True], [False, True]] :: [[Bool]]
	-- List of lists!
```


Тип пустого списка **полиморфен**, т.е. элемент пустого списка может иметь любой тип. Также можно делать список списков!

Еще один вариант коструировать списки: синтаксический сахар, позволяющий быстро создавать списки-арифметические прогрессии:


```Haskell
	>> [1..10]
	[1,2,3,4,5,6,7,8,9,10]

	>> [1,3..11]
	[1,3,5,7,9,11]

	>> [1..] -- попробуйте, для завершения процесса нажмите Ctrl+C.
```


## Функции со списками.
		

```Haskell
	head :: [a] -> a

	---
	>> head [1,2,3]
	1
```
Возвращает первый элемент списка, если список не пуст. Иначе возвращает ошибку.


```Haskell
	tail :: [a] -> [a]

	---
	>> tail [1,2,3]
	[2,3]
```

Возвращает хвост списка, т.е. все элементы кроме первого, если список не пуст. Иначе возвращает ошибку.


```Haskell
	(++) :: [a] -> [a] -> [a]

	---
	>> [1,2,3] ++ [10, 20, 30]
	[1, 2, 3, 10, 20, 30]
```

Сложение списков, т.е. конкатенация.


```Haskell
	(:) :: a -> [a] -> [a]

	---
	>> 1 : [2, 3]
	[1, 2, 3]

	>> 1 : 2 : 3 : []
	[1, 2, 3]
```

Добавление в голову списка. Это правоаасоциативный оператор, поэтому последнее выражение можно писать без скобок. На самом деле это не оператор, а конструктор списка (поймем когда будем изучать типы данных).

```Haskell
	take :: Int -> [a] -> [a]

	---
	>> take 3 [1,2,3,4,5,6]
	[1, 2, 3]

	>> take 8 [1,2,3]
	[1, 2, 3]
```

Взять первые `n` элементов из списка. Если мы хотим взять элементов больше, чем в списке, то вернется весь список.

Еще несколько функций без описания:



```Haskell
	>> length [1,2,3]
	3

	>> reverse [1,2,3]
	[3,2,1]

	>> last [1,2,3]
	3 

	>> init [1,2,3]
	[1,2]
```


## `map`, `zip`, `zipWith`
Списки можно модифицировать при помощи функций. Одна из основных -- функция `map`. 
Посмотрим на её тип:


```haskell
	>>:t map
	>>map :: (a -> b) -> [a] -> [b]
```


Мы видим, что эта функция принимает первым аргументом функцию `(a -> b)`, а вторым аргументом список `[a]`.
Уже из типа очевидно, что, для того чтобы получить в качестве результата список типа `[b]`, нужно применить данную функцию к каждому элементу списка. Действительно, посмотрим на примере:
	


```haskell
	>> map (+2) [1, 2, 3]
	[3, 4, 5]
	-- add 2 to each element

	>> map (== 42) [54, 42, 83, 42, 42]
	[False, True, False, True, True]
	-- chech if the element equal to 42.

	>> map (^2) [1, 2, 3, 4, 5]
	[1, 4, 9, 16, 25]
	-- square each element

	>> map (++ "!!!") ["Hello", "World"]
	["Hello!!!","World!!!"]

```


Ещё две важные функции -- `zip` и `zipWith`



```haskell
	>>:t zip
	zip :: [a] -> [b] -> [(a, b)]

	>>:t zipWith
	zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
```


	Функция zip берет два списка и "соединяет" их поэлементно в пары.
	Проще всего понять на примере:


```haskell
	>> zip [1,2,3] ['a', 'b', 'c']
	[(1,'a'),(2,'b'),(3,'c')]

```

Если размеры списков неодинаковы, то берется наименьший из размеров:


```haskell
	>> zip [1,2,3] ['a', 'b', 'c', 'd', 'e']
	[(1,'a'),(2,'b'),(3,'c')]
```


Функция `zipWith` берет функцию, два списка и "соединяет" их поэлементно c помощью этой функции.
Пример:


```haskell
	>> zipWith (+) [1,2,3] [100, 200, 300]
	[101, 202, 303]

	-- zipWith (+) [1,2,3] [100, 200, 300] ~>
	-- [1 + 100, 2 + 200, 3 + 300] ~>
	-- [101, 202, 303]

	>> zipWith (>) [13,22,36] [10, 48, 29]
	[True, False, True]
	
	>> zipWith max [13,22,36] [10, 48, 29]
	[13,48,36]

```


## Бесконечные списки
В хаскеле можно построить бесконечный список! Определим функцию `nat'`, которая стоит все натуральные числа начиная с данного:


```haskell

	nat' n = n : nat' (n + 1) 

	-- то есть nat' n -- это спискок nat' (n+1), которому в голову положили n.

	---


	>> nat' 1
	[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,
	18,19,20,21,22,23,24,25,26,27,28,29,30,31,
	32,33,34,35,36,37,38,39,40,41,42,43,44,45, 
	46,47,48,49,50,51,52,53,54,55,56,57,58,59,
	60,61,62,63,64,65,66,67,68,69,70,71,72,73,
	74,75,76,77,78,79,80,81,82,83,84,85,86,87...
```


Для того чтобы с ними работать можно использовать функцию `take`:


```haskell
	>> take 10 $ nat' 1
	[1,2,3,4,5,6,7,8,9,10]
```


Построим список ВСЕХ чисел фибоначчи. Напомним, что первые два числа фибоначчи равны `0` и `1`, а каждое следующее равно сумме двух предыдущих. Назовем наш список `fibs`. Первые два элемента так и запишем: `fibs = 0 : 1 : ...`

Напишем несколько следующих элементов:

* 1 =  1 + 0
* 2 =  1 + 1
* 3 =  2 + 1
* 5 =  3 + 2
* 8 =  5 + 3
* 13 = 8 + 5
* ...

Видно что справа стоит поэлементная сумма нашего списка чисел фибоначчи и того же самого списка, но без первого элемента. Т.е. нам надо сложить наш список `fibs` и список `tail fibs` (все элементы кроме первого). Сделать это можно с помощью функции `zipWith`.

Итак, наш список строится так:


```haskell
	fibs :: [Integer]
	fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
	
	---
	>> take 10 fibs
	[0,1,1,2,3,5,8,13,21,34]

	>> take 20 fibs
	[0,1,1,2,3,5,8,13,21,34,55,89,144,
	233,377,610,987,1597,2584,4181]


```
