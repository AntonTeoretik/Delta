

# [Лекция 3 -- Кортежи и списки.]{.class lang="ru-RU"}

:::::{.class lang="ru-RU"}
# Кортежи.
	
	Кортеж (tuple) -- это струтура данных, которая может быть хранить
	несколько произвольных значений. Эти значения могут быть разных типов,
	поэтому у кортежа всегда фиксирована длина. Типы при этом могут быть
	произвольные, даже другие кортежи или функции!

	Кортежи образуются с помощью круглых скобок и раделяющих запятых.
:::::


```haskell
	>> (4, 5)
	(4, 5)

	>> (20 + 2, 30 + 3)
	(22, 33)

	>> (True, 'c', 34) 
	(True, 'c', 34)
```

:::::{.class lang="ru-RU"}
	Заметим, что кортежа из одного элемента не существует: выражение (4) -- это просто значение. Однако существует кортеж из нуля элементов: (). 

	Он очень часто применяется в тех случаях, когда возвращаемое значение 
	функции не нужно (а нужно изменение) какого-либо состояния. Но об 
	этом мы поговорим когда будем изучать монады.

	Тип у кортежа выглядит таким образом:
:::::

```haskell
	>> :t (True, False)
	(True, False) :: (Bool, Bool)

	>> :t (True, 'c', 15)
	(True, 'c', 15) :: Num c => (Bool, Char, c) 
	-- 15 has a type c, with context Num

	>> :t ( ('c', True), False )
	( ('c', True), False ) :: ((Char, Bool), Bool)
	-- tuple inside a tuple!


	>> :t ( (&&), (&& True), (True && True) )
	( (&&), (&& True), (True && True) ) 
		:: (Bool -> Bool -> Bool, Bool -> Bool, Bool)
	-- functional types!

	>> :t () 
	() :: ()
	-- type of () is it self!


```
:::::{.class lang="ru-RU"}
	Видно, что в кортеж можно класть функции (разных типов), а так же 
	другие кортежи. Так же видно, что тип пустого кортежа -- это он сам,
	что, впрочем не мешает, потому что имена типов и имена значений 
	никогда не пересекаются.

## Функции для работы с кортежами.
	
	Кортеж из двух элементов называется парой. Для извлечения значений 
	в Haskell существуют функции fst (от слова first) и snd (от слова second).

	Их тип такой: 
:::::


```haskell
	>> :t fst
	fst :: (a, b) -> a

	>> :t snd
	snd :: (a, b) -> b

```
:::::{.class lang="ru-RU"}
	Примеры использования:
:::::


```haskell
	>> fst (1, True)
	1

	>> snd (1, True)
	True
```

:::::{.class lang="ru-RU"}
## Кортежи и сопоставления с образцом.
	Сопоставление с образцом можно делать так, чтобы извлекать
	значения из кортежа. Показать это проще на примере: давайте 
	реализуем функцию f, которая принимает кортеж типа
	(Bool, Integer, Integer), и возвращает сумму двух последних
	элементов если первый элемент True, а если он False возвращает 0

:::::


```haskell
	
	f :: (Bool, Integer, Integer) -> Integer
	f (True, a, b) = a + b
	f (False, _, _) = 0


	---

	>> f (True, 5, 2)
	7
	>> f (False, 10, 3)
	0
	>> f (False, undefined, undefined)
	0
	-- here is no error because of laziness.

```

:::::{.class lang="ru-RU"}
	Обратите внимание, что из-за ленивости языка, в случае если
	первый элемент кортежа False, то проверки двух последних
	аргументов не происходит! Значит там могут находиться выражения
	возвращающие ошибку (такое как undefined).

## Возвращение кортежей.
	Кортежи используются для того чтобы возвращать несколько значений.
	Пример: функция divMod возвращает результат целочисленного деления
	на число и остаток. Например, если разделить 10 на 3, то получится
	3 и остаток 1. Действительно:
:::::

```Haskell
	>> divMod 10 3
	(3,1)
	-- tuple!

```
:::::{.class lang="ru-RU"}
	Можно написать собственную функцию, возвращающую кортеж. 
	Для примера определим функцию, возвращающую сумму и разность
	двух аргументов.
:::::

```Haskell
	sumAndDiff :: (Num a) => a -> a -> (a, a)
	sumAndDiff x y = (x + y, x - y)
	
	---

	>> sumAndDiff 5 3
	(8, 2)

```

:::::{.class lang="ru-RU"}
# Списки
	Списки -- это тоже контейнеры, которые хранят набор данных.
	Отличие от кортежей -- это то, что они хранят в себе только 
	один тип. Преимущество -- функции могут принимать списки
	произвольной длины.

	Списки конструируются с помощью квадратных скобок. 
:::::

```Haskell
	>> [1,2,3]
	[1,2,3]

	>> [False, True]
	[False, True]

	>> ['H', 'e', 'l', 'l', 'o']
	"Hello"

```

:::::{.class lang="ru-RU"}
	Мы видим, что строка -- это просто список из элементов типа Char.


	Тип списка -- это [тип элемента списка]
:::::

```Haskell
	>> :t [True, False]
	[True, False] :: [Bool]


	>> :t ['H', 'e', 'l', 'l', 'o']
	['H', 'e', 'l', 'l', 'o'] :: [Char]

	>> :t [1, 2, 3]
	[1, 2, 3] :: Num a => [a]
	-- Because 1, 2, 3 has polymorphic type a, with context Num.

	>> :t []
	[] :: [a]

	>> :t [[True], [False, True]]
	[[True], [False, True]] :: [[Bool]]
	-- List of lists!
```

:::::{.class lang="ru-RU"}
	Тип пустого списка **полиморфен**, т.е. элемент пустого списка может
	иметь любой тип. Так же можно делать список списков!


	Еще один вариант коструировать списки: синтаксический сахар
:::::

```Haskell
	>> [1..10]
	[1,2,3,4,5,6,7,8,9,10]

	>> [1,3..11]
	[1,3,5,7,9,11]

	>> [1..] -- what is it?!
```

:::::{.class lang="ru-RU"}
## Функции со списками.
		
:::::

```Haskell
	head :: [a] -> a

	---
	>> head [1,2,3]
	1
```
:::::{.class lang="ru-RU"}
	Возвращает первый элемент списка, если список не пуст. 
	Иначе возвращает ошибку.
:::::
```Haskell
	tail :: [a] -> [a]

	---
	>> tail [1,2,3]
	[2,3]
```
:::::{.class lang="ru-RU"}
	Возвращает хвост списка, т.е. все элементы кроме первого, 
	если список не пуст. 
	Иначе возвращает ошибку.
:::::

```Haskell
	(++) :: [a] -> [a] -> [a]

	---
	>> [1,2,3] ++ [10, 20, 30]
	[1, 2, 3, 10, 20, 30]
```
:::::{.class lang="ru-RU"}
	Сложение списков, т.е. конкатенация.
:::::

```Haskell
	(:) :: a -> [a] -> [a]

	---
	>> 1 : [2, 3]
	[1, 2, 3]

	>> 1 : 2 : 3 : []
	[1, 2, 3]
```
:::::{.class lang="ru-RU"}
	Добавление в голову списка. 
	Это правоаасоциативный оператор, поэтому последнее выражение 
	можно писать без скобок.
	На самом деле это не оператор, а конструктор списка (поймем когда будем изучать типы данных).
:::::
```Haskell
	take :: Int -> [a] -> [a]

	---
	>> take 3 [1,2,3,4,5,6]
	[1, 2, 3]

	>> take 8 [1,2,3]
	[1, 2, 3]
```
:::::{.class lang="ru-RU"}
	Взять первые n элементов из списка. Если мы хотим взять элементов
	больше, чем в списке, то вернется весь список.

	Еще несколько функций без описания
:::::


```Haskell
	>> length [1,2,3]
	3

	>> reverse [1,2,3]
	[3,2,1]

	>> last [1,2,3]
	3 

	>> init [1,2,3]
	[1,2]
```

:::::{.class lang="ru-RU"}
## map, zip, zipWith
	Списки можно модифицировать при помощи функций. Одна из основных -- функция map. 
 	Посмотрим на ее тип:
:::::

```haskell
	>>:t map
	>>map :: (a -> b) -> [a] -> [b]
```

:::::{.class lang="ru-RU"}
	Мы видим, что эта функция принимает первым аргументом
	функцию (a -> b), а вторым аргументом список [a].
	Уже из типа очевидно, что, для того чтобы получить в
	качестве результата список типа [b], нужно применить 
	данную функцию к каждому элементу списка. Действительно,
	посмотрим на примере:
	
:::::

```haskell
	>>map (+2) [1, 2, 3]
	[3, 4, 5]
	-- add 2 to each element

	>>map (== 42) [54, 42, 83, 42, 42]
	[False, True, False, True, True]
	-- chech if the element equal to 42.

	>>map (^2) [1, 2, 3, 4, 5]
	[1, 4, 9, 16, 25]
	-- square each element

	>>map (++ "!!!") ["Hello", "World"]
	["Hello!!!","World!!!"]

```

:::::{.class lang="ru-RU"}
	Еще две важные функции -- zip и zipWith

:::::

```haskell
	>>:t zip
	zip :: [a] -> [b] -> [(a, b)]

	>>:t zipWith
	zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
```

:::::{.class lang="ru-RU"}
	Функция zip берет два списка и "соединяет" их поэлементно в пары.
	Проще всего понять на примере:
:::::

```haskell
	>>zip [1,2,3] ['a', 'b', 'c']
	[(1,'a'),(2,'b'),(3,'c')]

```
:::::{.class lang="ru-RU"}
	Если размеры списков неодинаковы, то берется наименьший из размеров:
:::::

```haskell
	>>zip [1,2,3] ['a', 'b', 'c', 'd', 'e']
	[(1,'a'),(2,'b'),(3,'c')]
```

:::::{.class lang="ru-RU"}
	Функция zipWith берет функцию, два списка и "соединяет" их поэлементно c помощью этой функции.
	Пример:
:::::

```haskell
	>> zipWith (+) [1,2,3] [100, 200, 300]
	[101, 202, 303]

	-- zipWith (+) [1,2,3] [100, 200, 300] ~>
	-- [1 + 100, 2 + 200, 3 + 300] ~>
	-- [101, 202, 303]

	>> zipWith (>) [13,22,36] [10, 48, 29]
	[True, False, True]
	
	>> zipWith max [13,22,36] [10, 48, 29]
	[13,48,36]

```

:::::{.class lang="ru-RU"}
## Бесконечные списки
	В хаскеле можно построить бесконечный список! 
	Определим функцию nat', которая стоит все натуральные числа 
	с данного:
:::::

```haskell

	nat' n = n : nat' (n + 1)

	---


	>> nat' 1
	[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,
	18,19,20,21,22,23,24,25,26,27,28,29,30,31,
	32,33,34,35,36,37,38,39,40,41,42,43,44,45, 
	46,47,48,49,50,51,52,53,54,55,56,57,58,59,
	60,61,62,63,64,65,66,67,68,69,70,71,72,73,
	74,75,76,77,78,79,80,81,82,83,84,85,86,87...
```

:::::{.class lang="ru-RU"}
	Для того чтобы с ними работать можно использовать функцию take:
:::::

```haskell
	>> take 10 $ nat' 1
	[1,2,3,4,5,6,7,8,9,10]
```

:::::{.class lang="ru-RU"}
	Построим список ВСЕХ чисел фибоначчи. Напомним, что первые два
	числа фибоначчи равны 0 и 1, а каждое следующее равно сумме 
	двух предыдущих. Назовем наш список fibs. Первые два элемента 
	так и запишем: fibs = 0 : 1 : ...
	Напишем несколько следующих элементов:
	1 =  1 + 0
	2 =  1 + 1
	3 =  2 + 1
	5 =  3 + 2
	8 =  5 + 3
	13 = 8 + 5
	...

	Видно что справа стоит поэлементная сумма нашего списка чисел
	фибоначчи и того же самого списка, но без первого элемента.

	Т.е. нам надо сложить наш список fibs и список tail fibs (все
	элементы кроме первого)
	Сделать это можно с помощью функции zipWith.

	Итак, наш список строится так:
:::::

```haskell
	fibs :: [Integer]
	fibs = 0 : 1 : ( zipWith (+) fibs (tail fibs) )
	
	---
	>> take 10 fibs
	[0,1,1,2,3,5,8,13,21,34]
	>> take 20 fibs
	[0,1,1,2,3,5,8,13,21,34,55,89,144,
	233,377,610,987,1597,2584,4181]


```
