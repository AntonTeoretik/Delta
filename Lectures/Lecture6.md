
# Лекция 6. Подробнее о классах типов. Модули и импортирование. Maybe, Either. 


# Собственные классы типов и instance

В Haskell можно создавать собственные классы типов. Для этого нужно указать название и список функций, которые для этого класса типов должны быть определены. 

Часто, после этого добавляют необходимые аксиомы, которым должны удовлетворять эти функции, однако Haskell не умеет отслеживать выполнение аксиом, поэтому их выполнение остается на совесть программисту. Давайте создадим класс `Group`, который реализует идею математической группы -- т.е. множества с одной обратимой ассоциативной операцией и нейтральным элементом. 

```Haskell

infixl 5 *.
class Group a where
  (*.) :: a -> a -> a -- это наша операция.
  invert  :: a -> a   -- для каждого элемента можно вернуть обратный.
  neutral :: a        -- нейтральный элемент.

-- Аксиомы группы
-- (*.) ассоциативна -- x *. y *. z = (x *. y) *. z = x *. (y *. z),
-- neutral *. x == x
-- x *. neutral == x
-- x *. (invert x) == neutral
-- (invert x) *. x == neutral

```

Для того, чтобы сделать какой-либо тип представителем класса `Grouph` надо написать ключевое слово `instance`, далее название нашего класса типов и названия того типа, который мы хотим реализовать. Пример -- `Integer` является группой по сложению:

```Haskell

instance Group Integer where
  neutral = 0
  invert = negate
  (*.) = (+)

--
>> 1 *. 4
5
>> invert 4
-4
>> neutral :: Integer
0

```

Можно реализовать тривиальную группу из одного элемента, т.е. реализовать для типа `()`

```Haskell

instance Group () where
  neutral = ()
  invert = id
  () *. () = ()

--
>> () *. ()
()
>> invert ()
()
>> neutral :: ()
()

```

Можно реализовывать представителей для встроенных классов типов. Например, допустим, у нас есть тип `Complex`, реализующий комплексные числа. Мы хотим сделать его представителем класса типов `Num` и `Show`, т.е. уметь складывать, вычитать и умножать комплексные числа, а также показывать их в консоль.

Мы можем написать такое:


```Haskell

data Complex = Complex Double Double
  deriving (Eq)

instance Show Complex where
  show (Complex x y) = show x ++ (if y >= 0 then " + i*" else " - i*") ++ show (abs y) -- реализация красивого Show для комплексных чисел.

instance Num Complex where
  Complex x1 y1 + Complex x2 y2 = Complex (x1 + x2) (y1 + y2) 
  negate (Complex x y) = Complex (-x) (-y)
  Complex x1 y1 * Complex x2 y2 = Complex (x1 * x2 - y1 * y2) (x1 * y2 + x2* y1 ) 
  abs x = x -- это приходится реализовывать как-то, у нас -- бессмысленно.
  signum x = 1
  fromInteger n = Complex (fromInteger n) 0 

```


# Полезные типы

## `Maybe`

В стандартной библиотеке существует однопараметрический тип `Maybe`, который определён следующим образом:

```Haskell
data Maybe a = Nothing | Just a

```

Таким образом, это тип, который позволяет "завернуть" наш тип в некоторую оболочку, для того, чтобы корректно обрабатывать исключительные ситуации. Рассмотрим на примере:
допустим мы хотим найти первый четный элемент в списке, а если в списке нет чётных элементов, то мы не хотим выдавать ошибку. Для этого отлично подойдёт наш тип `Maybe`.

```Haskell
findOdd :: [Integer] -> Maybe Integer
findOdd [] = Nothing -- если мы принимаем пустой список, то возвращаем Nothing
findOdd (x : xs) | x `mod` 2 == 0  = Just x     -- если голова списка -- четный элемент, то возвращаем его.
                 | otherwise       = findOdd xs -- иначе возвращаем первый четный элемент хвоста нашего списка.

```

Заметим, что мы пользовались тем, что любой список выглядит как `[]` или `x : xs`. 

Много встроенных функций возвращают тип `Maybe`: например полезной бывает функция `find` из модуля `Data.List`, частный случай которой мы реализовали выше:

```Haskell
	find :: Foldable t => (a -> Bool) -> t a -> Maybe a
```
 
Класс типов `Foldable` -- это класс, реализующий *контейнеры*, в частности список является представителем этого класса типов. 

`find` берет некоторую функцию типа `a -> Bool` (такие функции называются предикатами), контейнер, содержащий элементы типа `a` (строчку `t a` можете заменить для себя на `[a]`), и возвращает первый элемент, на котором предикат возвращает истину. При этом если он есть, то он упаковывается в оболочку `Just` (чтобы иметь тип `Maybe`), а если его нет, то возвращается `Nothing`.

Пример:

```Haskell
>> import Data.List
>> find ( > 5 ) [1,2,3,4,5,6,7,8]
Just 6

>> find ( > 5 ) [1,2,3,4] 
Nothing

```

## `Either`

Это пример двух параметрического типа. Определён он так:

```Haskell

data Either a b = Left a | Right b

```

Видно, что `Either` представляет собой две альтернативы -- либо `Right` и какой-то тип, либо `Left` и какой-то другой тип. На практике часто тип `a` фиксируют, чтобы тип `Either a` стал параметрическим типом. При этом `Right` возвращают в том случае, когда значение каких-то вычислений "правильное", а `Left` -- если не правильное, и помещают в него какой-то лог. 

Для примера, допустим мы хотим реализовать функцию `findOddSafe`, которая бы примимала бы максимальную длину списка, которую она может обработать, для того, чтобы корректно работать с бесконечными списками. При этом хочется, чтобы в случае, если элементов в списке больше, чем она может обработать, возвращалась бы одно сообщение (например `"No odds found: maximum depth reached"`), а если список просто не содержит четных элементов -- то сообщение что четных элементов нет (`There is no odd numbers in the list`)


```Haskell

findOddSafe :: Int -> [Integer] -> Either String Integer
findOddSafe _ [] = Left "There is no odd numbers in the list"
findOddSafe n (x : xs) | n < 0 = Left "No odds found: maximum depth reached" 
					   | x `mod` 2 == 0  = Right x
                 	   | otherwise       = findOddSafe (n-1) xs


--

>> findOddSafe 100 [1,3..]
Left "No odds found: maximum depth reached"

>> findOddSafe 100 [1,3..50]
Left "There is no odd numbers in the list"

>> findOddSafe 100 $ [1,2,3] 
Right 2

```


Часто для обработки возвращаемых выражений удобно использовать конструкцию `case of`

```Haskell

doSomething :: [Integer] -> String
doSomething xs = case findOddSafe 100 xs of
	Rigth x -> "Everything ok: " ++ show x
	Left _  -> "Some error"


--
>> doSomething [1..]
"Everything ok: 2"

>> doSomething [1,3..]
"Some error: No odds found: maximum depth reached"


```




