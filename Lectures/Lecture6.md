
# Лекция 6. Метки полей и всякая всячина.

# Метки полей.

Часто бывает удобно делать так, чтобы поля типов имели название. Для типов-произведений такой способ есть. Допустим, мы хотим создать тип `Person`, который будет хранить в себе имя человека, фамилию и возраст. Мы могли бы сделать так:

```Haskell
data Person = Person String String Int
  deriving (Show, Eq)
```

Однако, не очень понятно за что отвечает первый `String`, а за что второй. К тому же хочется получить функции, которые узнают имя человека, фамилию и возраст. В Haskell существует такой синтаксис:

```Haskell 

data Person = Person { firstsName :: String, lastName :: String, age :: Int }
  deriving (Show, Eq)

```

Теперь можно делать три вещи:
* извлекать из нашего типа значение отдельных полей с помощью функций `firstName`, `lastName` и `age`, и наоборот, создавать при помощи них новую персону:

```Haskell
>> let bill = Person "Bill" "Ivanov" 17
>> firstName bill
"Bill"

>> let john = Person {age = 13, lastName = "Petrov", firstName = "John"} -- можем менять порядок!


```


* использовать их в сопоставлении с образцом, с возможностью выделить только те поля, которые нужно:

```Haskell

welcomeBill :: Person -> String
welcomeBill ( Person {firstName = "Bill"} ) = "Welcome, Bill"
welcomeBill _ = "You are not Bill".

>> let bill = Person "Bill" "Ivanov" 17
>> welcomeBill bill
Person {firstName = "John", lastName = "Ivanov", age = 17}

```

* менять часть полей (точнее возвращать новую переменную с измененными полями)

```Haskell

changeName :: String -> Person -> Person
changeName new_name pers = pers {firstName = new_name} 

>> let bill = Person "Bill" "Ivanov" 17
>> changeName "John" bill


```


# Анонимные функции.

Во многих языках есть возможность создавать неименнованные функции, которые используется только в одном месте программы и незаслуживают отдельного названия. В Haskell такая возможно тоже есть. Допустим мы хотим создать функцию, которая складывает возвращает сумму квадратов двух своих аргументов (для того чтобы например, передать её в функцию `zipWith`). Для этого будем использовать следующий синтаксис: `\АРГУМЕНТ_1, АРГУМЕНТ_2, ..., АРГУМЕНТ_N -> ВЫРАЖЕНИЕ`. В данном случае наша функция будет выглядеть так: `\x y -> x^2 + y^2`. Лямбда функции можно использоавать в любом выражении, например в другой лямбда-функции. Вызов функции от аргументов выглядит как обычно: `(\x y -> x^2 + y^2) 2 2 -- это равно 8`. Пример использования:

```Haskell

>> zipWith (\x y -> x^2 + y^2) [1, 2, 3] [10, 20, 30]
[101, 404, 909]


>> map (\x -> (x, x)) [1, 2, 3] -- делаем из каждого элемента пару.
[(1, 1), (2, 2), (3, 3)] 


```

Замечание: символ `\` используется потому, что он наиболее похож на греческий символ "лямбда".

Рассмотрим, в частности, как устроены обычные функции. Во-второй лекции мы узнали, что функции многих аргументов это на самом деле функция одного аргумента, которая возвращает функцию. Давайте посмотрим, как при помощи лямбда функций можно явно показать, что именно за функция возвращается:

Допустим определена функция:

```Haskell

f :: Int -> Int -> Int
f x y = x ^ 2 + y ^ 2

```

Оказывается можно теперь, с помощью лямбда-функций явно указать возвращаемую функцию, в случае если передан только один аргумент.

В данном случае наша функция `f` могла бы быть определена так:

```Haskell

f :: Int -> (Int -> Int)
f x = \y -> x ^ 2 + y ^ 2

```

Видно, что наш аргумент ` y ` "переполз" из левой части в правую под лямбда-выражение. Можно точно так же поступить теперь с ` x `!

```Haskell

f :: Int -> (Int -> Int)
f = \x -> (\y -> x ^ 2 + y ^ 2)


```

Таким образом, на самом деле все выражения в Haskell являются неименованными функциями. Последнее выражение можно записать без скобок -- ` \x -> \y -> x^2 + y^2 `. Кстати, на самом деле все лямбда функции от нескольких аргументов разбираются в цепочку обычных лямбда функций: ` \x y z -> ... ` это тоже самое, что ` \x -> \y -> \z -> ... ` 



# `case of`

Иногда требуется использовать сопоставление с образцом внутри функций, а не при их определении. Для этого используется конструкция 

``` 
  case ВЫРАЖЕНИЕ of
    ОБРАЗЕЦ_1 -> ВЫРАЖЕНИЕ_1
    ОБРАЗЕЦ_2 -> ВЫРАЖЕНИЕ_2
    ...
    ОБРАЗЕЦ_N -> ВЫРАЖЕНИЕ_N

```

Пример использования:

```Haskell
complexCalculations :: Integer -> [Integer]
complexCalculations n = if n > 0 then [n * 2 + 82] else n : complexCalculation (n - 1)

f :: Integer -> String
f n = case complexCalculation (n + 2) of
  [] -> "Hmmm, the empty list!"
  [1, 2, 3] -> "Probably never happens"
  (x : xs) -> show x ++ show $ length xs


```





# Полезные типы

## `Maybe`

В стандартной библиотеке существует однопараметрический тип `Maybe`, который определён следующим образом:

```Haskell
data Maybe a = Nothing | Just a

```

Таким образом, это тип, который позволяет "завернуть" наш тип в некоторую оболочку, для того, чтобы корректно обрабатывать исключительные ситуации. Рассмотрим на примере:
допустим мы хотим найти первый четный элемент в списке, а если в списке нет чётных элементов, то мы не хотим выдавать ошибку. Для этого отлично подойдёт наш тип `Maybe`.

```Haskell
findOdd :: [Integer] -> Maybe Integer
findOdd [] = Nothing -- если мы принимаем пустой список, то возвращаем Nothing
findOdd (x : xs) | x `mod` 2 == 0  = Just x     -- если голова списка -- четный элемент, то возвращаем его.
                 | otherwise       = findOdd xs -- иначе возвращаем первый четный элемент хвоста нашего списка.

```

Заметим, что мы пользовались тем, что любой список выглядит как `[]` или `x : xs`. 

Много встроенных функций возвращают тип `Maybe`: например полезной бывает функция `find` из модуля `Data.List`, частный случай которой мы реализовали выше:

```Haskell
	find :: Foldable t => (a -> Bool) -> t a -> Maybe a
```
 
Класс типов `Foldable` -- это класс, реализующий *контейнеры*, в частности список является представителем этого класса типов. 

`find` берет некоторую функцию типа `a -> Bool` (такие функции называются предикатами), контейнер, содержащий элементы типа `a` (строчку `t a` можете заменить для себя на `[a]`), и возвращает первый элемент, на котором предикат возвращает истину. При этом если он есть, то он упаковывается в оболочку `Just` (чтобы иметь тип `Maybe`), а если его нет, то возвращается `Nothing`.

Пример:

```Haskell
>> import Data.List
>> find ( > 5 ) [1,2,3,4,5,6,7,8]
Just 6

>> find ( > 5 ) [1,2,3,4] 
Nothing

```

## `Either`

Это пример двух параметрического типа. Определён он так:

```Haskell

data Either a b = Left a | Right b

```

Видно, что `Either` представляет собой две альтернативы -- либо `Right` и какой-то тип, либо `Left` и какой-то другой тип. На практике часто тип `a` фиксируют, чтобы тип `Either a` стал параметрическим типом. При этом `Right` возвращают в том случае, когда значение каких-то вычислений "правильное", а `Left` -- если не правильное, и помещают в него какой-то лог. 

Для примера, допустим мы хотим реализовать функцию `findOddSafe`, которая бы примимала бы максимальную длину списка, которую она может обработать, для того, чтобы корректно работать с бесконечными списками. При этом хочется, чтобы в случае, если элементов в списке больше, чем она может обработать, возвращалась бы одно сообщение (например `"No odds found: maximum depth reached"`), а если список просто не содержит четных элементов -- то сообщение что четных элементов нет (`There is no odd numbers in the list`)


```Haskell

findOddSafe :: Int -> [Integer] -> Either String Integer
findOddSafe _ [] = Left "There is no odd numbers in the list"
findOddSafe n (x : xs) | n < 0           = Left "No odds found: maximum depth reached" 
					             | x `mod` 2 == 0  = Right x
                 	     | otherwise       = findOddSafe (n-1) xs


--

>> findOddSafe 100 [1,3..]
Left "No odds found: maximum depth reached"

>> findOddSafe 100 [1,3..50]
Left "There is no odd numbers in the list"

>> findOddSafe 100 $ [1,2,3] 
Right 2

```


Часто для обработки возвращаемых выражений удобно использовать конструкцию `case of`

```Haskell

doSomething :: [Integer] -> String
doSomething xs = case findOddSafe 100 xs of
	Rigth x -> "Everything ok: " ++ show x
	Left _  -> "Some error"


--
>> doSomething [1..]
"Everything ok: 2"

>> doSomething [1,3..]
"Some error: No odds found: maximum depth reached"


```




