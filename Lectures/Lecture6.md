
# Лекция 6. Maybe, Either. Подробнее о классах типов. Модули и импортирование модулей.


## Тип данных Maybe

В стандартной библиотеке существует однопараметрический тип `Maybe`, который определён следующим образом:

```Haskell
data Maybe a = Nothing | Just a

```

Таким образом, это тип, который позволяет "завернуть" наш тип в некоторую оболочку, для того, чтобы корректно обрабатывать исключительные ситуации. Рассмотрим на примере:
допустим мы хотим найти первый четный элемент в списке, а если в списке нет чётных элементов, то мы не хотим выдавать ошибку. Для этого отлично подойдёт наш тип `Maybe`.

```Haskell
findOdd :: [Integer] -> Maybe Integer
findOdd [] = Nothing -- если мы принимаем пустой список, то возвращаем Nothing
findOdd (x : xs) | x `mod` 2 == 0  = Just x     -- если голова списка -- четный элемент, то возвращаем его.
                 | otherwise       = findOdd xs -- иначе возвращаем первый четный элемент хвоста нашего списка.

```

Заметим, что мы пользовались тем, что любой список выглядит как `[]` или `x : xs`. 

Много встроенных функций возвращают тип `Maybe`: например полезной бывает функция `find` из модуля `Data.List`, частный случай которой мы реализовали выше:

```Haskell
	find :: Foldable t => (a -> Bool) -> t a -> Maybe a
```
 
Класс типов `Foldable` -- это класс, реализующий *контейнеры*, в частности список является представителем этого класса типов. 

`find` берет некоторую функцию типа `a -> Bool` (такие функции называются предикатами), контейнер, содержащий элементы типа `a` (строчку `t a` можете заменить для себя на `[a]`), и возвращает первый элемент, на котором предикат возвращает истину. При этом если он есть, то он упаковывается в оболочку `Just` (чтобы иметь тип `Maybe`), а если его нет, то возвращается `Nothing`.

Пример:

```Haskell
>> import Data.List
>> find ( > 5 ) [1,2,3,4,5,6,7,8]
Just 6

>> find ( > 5 ) [1,2,3,4] 
Nothing

```




