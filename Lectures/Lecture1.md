
# Лекция 1 -- выражения и функции


# Парадигма:

Программа на Haskell представляет собой набор выражений.
Выполнить программу -- означает редуцировать выражения до тех пор, пока можно. 
Пример редукции выражения:


```haskell

>> 3 + 4 * 5
23

-- 3 + 4 * 5 ~> 3 + 20 ~> 23

>> max (2 + 5) 10 + 12
20

-- max (2 + 5) 10 + 12 ~> max 7 10 + 12 ~> 10 + 12 ~> 20
```


# Базовые выражения: 

## Арифметические


```haskell 
a + b , a - b, a * b, a / b, a ** b, a ^ b, (-a)

a == b, a /= b
a > b, a < b, a <= b, a >= b -- сравнение


>> 3 ^ 2
9

>> 4 > 2
True

>> 3 /= 3
False

```



## Булевы выражения:



```haskell 
a && b, a || b, not a

True
False

>> True && False
False

>> (2 == 3) || True
True

>> not False
True

```



## Выражение `if then else`:

`if ( логическое выражение ) else (Выражение1) then (Выражение2)`

Выражение1 и Выражение2 должны быть одного **типа**. Если логическое выражение равно (т.е. редуцируется в) `True`, то выполняется первая ветка, иначе -- вторая. Вычисления производятся *лениво*, т.е. то выражение, которое не требует немедленного подсчета, не будет вычисляться.




```haskell 

>> if (1 > 0) then 5 else 10
5


>> if ( False ) then 42 else (-5)
-5

{-
if 2 * 2 == 4 then 42 else 100 ~>
if 4 == 4 then 42 else 100 ~>
if True then 42 else 100 ~> 
42 
-}

```



## Выражения `error` и `undefined`.

`error "Сообщение"` --- завершает программу с сообщением об ошибке в тот момент, когда требуется вычислить это выражение.

`undefined` --- завершает программу со стандартным сообщением об ошибке в тот момент, когда требуется вычислить это выражение. Подходит для еще нереализованных функций.

Демонстрация ленивости:



```haskell 

>> if (1 > 0) then 4 else (error "My error message")
4

```


Поскольку `(1 > 0) == True`, то ошибки не случится, так как Haskell не будет вычислять часть после `else`.

## Выражение let ... in.

Используется, когда нужно обозначить некоторое большое выражение (или несколько).

Использование: `let НАЗВАНИЕ1 = ВЫРАЖЕНИЕ1; НАЗВАНИЕ2 = ВЫРАЖЕНИЕ2; ... in ВЫРАЖЕНИЕ`


```haskell


>> let bigexpr = (max 5 10 - 8) ^ 2 in bigexpr ^ 5
1024


{-
let bigexpr = (max 5 10 - 8) ^ 2 in bigexpr ^ 5 ~>
let bigexpr = (10 - 8) ^ 2 in bigexpr ^ 5 ~>
let bigexpr = 2 ^ 2 in bigexpr ^ 5 ~>
let bigexpr = 4 in bigexpr ^ 5 ~>
let bigexpr = 4 in 4 ^ 5 ~>
4 ^ 5 ~> 1024

-}


>> let x = max 5 6; y = 20^2 - 399 in x + y
7


{-
let x = max 5 6; y = 20^2 - 399 in x + y ~>
let x = 6; y = 400 - 399 in x + y ~>
let x = 6; y = 1 in x + y ~>
let x = 6; y = 1 in 6 + 1 ~>
6 + 1 ~> 7

-}

```




# Понятие функции:

**Функция** -- это именованное выражение. Функция может зависеть от аргументов (любого числа). Применение функции к аргументам пишем без знаков препинания (через пробел):
* Вместо f(x) пишем f x,
* вместо f(x, y, z) пишем f x y z.

Функции в Haskell чистые, т.е. при фиксированных аргументах всегда будет возвращаться один и тот же результат.

Бывают функции от нуля аргументов -- это просто константы.

## Математические функции:




```haskell 
floor a, sqrt a, max a b, min a b, ...

pi -- mathematical constant pi (it is function with zero arguments)


>> floor 3.5
3


>> max 2 3
3


>> pi
3.141592653589793


```


## Собственные функции:

Синтаксис:

`НАЗВАНИЕ АРГУМЕНТ1 АРГУМЕНТ2 ... = ВЫРАЖЕНИЕ (использующее аргументы)`

Название должно начинаться с маленькой буквы. Разрешено использовать символы ', _ .




```haskell


-- Пишем свои функции

add3 a b c = a + b + c

summOfSquares a b = a^2 + b^2

safeDiv a b = if b /= 0 then a / b else (error "Division by zero!")



```


В функциях можно использовать любые выражения, включая эти самые функции (рекурсия).



```haskell


add4 a b c d = add3 a b c + d  -- используем ранее определенную функцию

factorial n = if n == 0 then 1 else n * factorial (n - 1) -- рекурсивное определение


```


## Механизм сопоставления с образцом:

Использовать `if then else` неудобно.
Можно задавать функции с помощью **уравнений**!



```haskell


factorial' 0 = 1          -- теперь выражение factorial' 0 всегда будет равно 1
factorial' n = n * factorial (n-1) 

--

-- factorial' 3 ~> 3 * factorial' (3 - 1) ~> 
-- 3 * factorial' 2 ~> 3 * (2 * factorial' 1) ~>
-- 3 * ( 2 * (1 * factorial 0) ) ~> 3 * (2 * (1 * 1)) ~> 6
```


Порядок проверки -- сверху вниз, слева направо. В предыдущем примере, если аргумент функции равен нулю, то возвращается 1, если не равен нулю, то переходим к следующей проверке. Если поменять строки местами, будет работать неправильно.

Если аргумент функции не важен в данном уравнении, можно использовать символ нижнего подчеркивания. Пример: функция двух аргументов const, которая возвращает свой первый аргумент; второй аргумент здесь называть не нужно, потому что он не используется.


```haskell

-- const -- стандартная функция так что пишем версию со '.
const' a _ = a


```


## Охранные выражения: проверка условий внутри уравнений.



```haskell

factorial' 0 = 1
factorial' n | n > 0 = n * factorial' (n-1)
             | n < 0 = error "Argument of factorial must be positive"



```


Порядок проверки также сверху вниз -- если не прошло первое охранное выражение, то переходим к следующему.
Для того чтобы разобрать "все остальные случаи", можно использовать встроенную функцию `otherwise`:

```haskell

factorial'' 0 = 1
factorial'' n | n > 0 = n * factorial' (n-1)
              | otherwise = error "Argument of factorial must be positive"

```

## Конструкция `where`

Работает внутри функций -- как let ... in, но наоборот. Не является выражением, работает только в теле функции.



```haskell



-- without where
f a b c = max (a * b * c) (a + b + c) + (a * b * c) ^ (a + b + c)

-- same with where
f' a b c = max x y + x ^ y
  where
    x = a * b * c
    y = a + b + c


```

В частности, используя `where`, можно определять локальные функции, т.е. те функции, которые нужны только внутри данной. Пример:

```haskell


function a b c = average a b c + max3 a b c + factorial''' a
  where
    -- объявление функции внутри функции!
    average x y z = (x + y + z) / 3
    max3 x y z = max x (max y z)
    
    -- можно даже более сложный вариант -- с использованием охранных выражений
    factorial''' 0 = 1
    factorial''' n | n > 0 = n * factorial' (n-1)
                   | otherwise = error "Argument of factorial must be positive"


```