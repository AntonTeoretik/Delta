
# Лекция 5 -- Рекурсивные и параметрические типы. Анонимные функции и выражение case of. 

## Рекурсивные типы.

В прошлой лекции мы познакомились с возможностью писать новые типы данных используя старые типы. Общий синтаксис выглядел таким образом:

```Haskell
data НАЗВАНИЕ_ТИПА = КОНСТРУКТОР_1 ТИП_11 ... ТИП_1N_1
                   | КОНСТРУКТОР_2 ТИП_21 ... ТИП_2N_2
                 ...
                   | КОНСТРУКТОР_M ТИП_M1 ... ТИП_MN_M
```

В хаскеле есть возможность в аргументе конструктора данных указать не существующий тип, а тот же самый тип, который мы определяем. Это нужно для рекурсивного определения типов. Рассмотрим на примере: допустим мы хотим реализовать тип двоичного дерева. Оно должно состоять из узлов, где каждый узел является либо листом, который хранит некоторое значени (допустим типа `Double`), либо узлом, в котором записано значение и есть два потомка -- точно таких же бинарных дерева.
Примерная схема может выглядеть так:


```
           4 <- узел
          / \
         /   \
лист -> 2     3  <- узел
             / \   
            /   \
           /     \ 
          1       9  <- лист
```


Итак напишем наш тип `BTree`. Он имеет два конструктора данных: `Leaf` -- лист и `Node` -- узел. Конструктор `Leaf` должен принимать на вход один агрумент типа `Double` -- то значение, которое в нём хранится. Конструктор `Node` должен принимать помимо значения типа `Double` ещё два аргумента -- два поддерева, у которых тип -- это тот, который мы сейчас создаём -- `BTree`. Полная реализация этого типа выглядит так:

```Haskell
data BTree = Leaf Double              -- лист.
           | Node BTree Double BTree  -- левое поддерево, значение в узле и правое поддерево.
  deriving (Show, Eq)

```

Как и в прошлый раз, значения нашего типа **всегда** будут выглядеть так: либо `Leaf x`, либо `Node tr1 x tr2`, где `tr1` и `tr2` -- это значения типа `BTree`.
Побробуем сконструировать дерево, которое отвечает примеру на схеме:

* Мы видим, что верхний узел содержит значение `4`. Поэтому наше дерево будет иметь такой вид: ` Node tr1 4 tr2 `. `tr1` и `tr2` -- это деревья, которые нам надо сконструировать.

* Левое поддерево `tr1` -- это просто лист, хранящий значение `2`. Поэтому `tr1 = Leaf 2`.

* Правое поддерево -- это снова дерево. В вершине у него значение `3`, значит у него такое вид  `tr2 = Node tr21 3 tr22`, где `tr21` и `tr22` -- это снова деревья.

* Нетрудно видеть, что `tr21` и `tr22` -- это просто листья: `tr21 = Leaf 1`, `tr22 = Leaf 9`.

Итак, мы можем создать константу `myTree`, которая будет хранить наше дерево:

```Haskell
myTree :: BTree
myTree = Node tr1 4 tr2
  where
    tr1 = Leaf 2
    tr2 = Node tr21 3 tr22  -- заметим, что здесь дополнительного where не нужно.
    tr21 = Leaf 1 
    tr22 = Leaf 9

---

>> myTree 
Node (Leaf 2.0) 4.0 (Node (Leaf 1.0) 3.0 (Leaf 9.0))

--- Можно было бы написать без where: myTree = Node (Leaf 2.0) 4.0 (Node (Leaf 1.0) 3.0 (Leaf 9.0))
```

Мы получили полноценное дерево!
Функции, которые разбирают рекурсивные типы данных обычно сами рекурсивны. Попробуем написать функцию, находящую сумму всех элементов дерева:


```Haskell
findSum :: BTree -> Double
findSum (Leaf x) = x       --- если наше дерево -- это лист, то сумма значений равна значение в этом листе
findSum (Node left_subtree x right_subtree) = findSum left_subtree + x + findSum right_subtree
  -- второй случай -- если наше дерево -- это узел, то надо найти сумму значений в поддеревьях, 
  -- сложить и не забыть про значение в узле.
---

>> findSum myTree 
19.0
-- действительно, (2) + 4 + ((1) + 3 + (9)) == 19
```

## Инфиксные конструкторы данных.

Несколько лекций назад было сказано, что названия операторов не могут начинаться со знака `:`. Теперь мы поймем почему. Допустим мы хотим реализовать свой собственный список `myList`. Логика будет такой: список -- это либо пустой список `Empty`, либо значение и хвост списка -- ещё один список. Можно было бы написать так:

```Haskell
data MyList = Empty
            | Val Double MyList 
  deriving (Show, Eq)     

```

Однако для того, чтобы создать список из даже трёх элементов, потребовалось бы написать громоздкую конструкцию из кучи скобочек:

```

>> Val 1 (Val 3 (Val 5 Empty) )   -- это список [1,2,3]
Val 1 (Val 3 (Val 5 Empty) )


```

Вместо этого хотелось бы написать оператор, который бы по значению слева и списку справа конструировал бы новый список. И это можно сделать!
Делается это точно так же, как и определение обычных операторов, отличие лишь в том, что оператор должен начинаться с двоеточия, и быть не просто функцией, а конструктором данных. Например, мы хотим чтобы списки могли конструироваться с помощью оператора `:+`, т.е. мы бы могли написать такое выражение: `2 :+ 3 :+ Empty `. Видно, что тогда оператор должен быть правоассоциативным: `2 :+ 3 :+ Empty  = 2 :+ (3 :+ Empty) `. Так же у него может быть приоритет, допустим `5`. Напишем новую реализацию `MyList` с учётом всех этих требований:

```Haskell
infixr 5 :+    --- определяем правоассоциативный оператор :+ с приоритетом 5.

data MyList = Empty
            | Double :+ MyList  -- используем этот оператор для конструирования данных.
  deriving (Show, Eq)  


---

>> 1 :+ 2 :+ 3 :+ Empty  -- Empty все ещё нужно писать, но выражение явно более красивое.
1.0 :+ (2.0 :+ (3.0 :+ Empty))
  -- настоящий вид нашего листа конечно со скобочками, но нам их не надо было писать из-за ассоциативности.

```

На самом деле мы сейчас реализовали самый настоящий список. Дело в том, что оператор `:` -- это точно такой же инфиксный конструктор данных. Так что в Haskell список реализован очень просто:

```Haskell
-- эта программа не корректна, она показывает лишь идею.


infixr 5 : --- самый простой оператор, начинающийся с двоеточия)

data [Double] = []                 -- список либо пустой
              | Double : [Double]  -- либо вида x : [...]
---

>> 1 : 2 : 3 : []
[1,2,3] -- функция show для списков определена отдельно, для того чтобы не писать 1 : (2 : (3 : []))

```

**Важное замечание**: теперь мы знаем, что списки -- это обычные рекурсивные типы данных. Поэтому мы можем реализовывать функции со списками, зная что любой список это **либо** `[]`, либо `x : xs`, где `x` -- это значение а `xs` -- это снова список (`xs` -- потому что множественное число от `x` :) )

Для примера напишем функцию `numberOfZeros` вычисляющую сколько в нашем списке типа `[Int]` нулей:

```Haskell   
numberOfZeros :: [Int] -> Int
numberOfZeros [] = 0 -- в пустом списке 0 нулей
numberOfZeros (0 : xs) = numberOfZeros xs + 1 -- если список начинается с нуля, то считаем сколько нулей в хвосте списка и прибавляем единичку
numberOfZeros (_ : xs) = numberOfZeros xs -- для всех остальных значений единичку не прибавляем.

---
  >> numberOfZeros [1, 2, 3, 0, 2, 4, 0]
  2

```

Пояснение -- здесь было использовано глубокое сопоставление с образцом. Проверка осуществляется таким образом:
* если список `[]`, то возвращаем ноль
* если список имеет вид `0 : xs`, то прибавляем единичку.
* если список имеет вид `_ : xs` -- то есть нам неважно какое значение в голове списка, то единичку не прибавляем. При этом это значение гарантировано не ноль, так как случай нуля был перепутан раньше. При этом если помнять последние две строчки местами, то случай нуля никогда не разбирается, потому что `_` удовлетворяет любому образцу!


# Параметрические типы

Итак, в предыдущих примерах мы реализовали тип `BTree` -- двоичное дерево, которое хранит в узлах элементы типа `Double`, и собственный список `MyList`, который так же хранит тип `Double`. Но что, если мы захотим хранить значения типа `Int`. Неужели придется создавать каждый раз новый тип? Конечно нет. Вспомним терминологию: если у нас есть тип `data A = ...`, то букву `A` мы называем не просто названием типа, а **конструктором типа**. Слово конструктор уже означает, что `A` в некотором смысле является функцией (в данном случае без аргументов), которая возвращает нам новый **тип**. Как и в случае с конструкторами данных, конструктор типа может принимать аргументы. Синтаксис в данном случае будет такой:

`data НАЗВАНИЕ_КОНСТРУТОРА_ТИПА ПЕРЕМЕННАЯ_ТИПА1 ПЕРЕМЕННАЯ_ТИПА2 ... ПЕРЕМЕННАЯ_ТИПАN = ... `

Указав переменные типа, мы сможем потом использовать в конструкторах данных значения переменных этого типа.

Проще всего это понять на примере:

Допустим, что мы хотим, чтобы тип `BTree` мог содержать в своих узлах произвольный тип `a`. Тогда нужно сделать следующее -- тип `Double` везде заменить на `a` и дописать переменную типа в конструктор типа. Обратите внимание -- теперь `BTree` -- это не полное название типа. Полным названием типа будет `BTree Double`, `BTree Int` или для произвольного типа `BTree a`. Это надо учитывать всегда! Все это будет выглядеть так:

```Haskell
data BTree a = Leaf a              -- лист, содержащий значение типа a.
           | Node (BTree a) a (BTree a)  -- заметим, что тип с BTree заменяется на (BTree a)

  deriving (Show, Eq)

```

Теперь мы можем создать собственные деревья типа `BTree Double`, `BTree Int` или, даже, `BTree (a -> a -> a)`!
```Haskel
myTreeDouble :: BTree Double -- не забываем, что BTree это не тип, а конструкто типа, надо давать ему аргументы.
myTreeDouble = Node tr1 4 tr2
  where
    tr1 = Leaf 2
    tr2 = Node tr21 3 tr22
    tr21 = Leaf 1 
    tr22 = Leaf 9


myTreeFunctional :: (Num a, Fractional a) => BTree (a -> a -> a) -- функциональное дерево!
myTreeFunctional = Node tr1 (+) tr2  -- сверху будет сложение двух чисел
  where
    tr1 = Leaf (-) -- тут минус
    tr2 = Node tr21 (/) tr22 -- деление
    tr21 = Leaf (*) -- умножение
    tr22 = Leaf (+) -- снова сложение

---

>> myTreeDouble
Node (Leaf 2.0) 4.0 (Node (Leaf 1.0) 3.0 (Leaf 9.0))

-- функциональное дерево получить не получится, но выглядит оно таким образом
{-
           (+) 
           / \
          /   \
        (-)   (/)         
              / \   
             /   \
            /     \ 
          (*)     (+)         

-}
```


# Анонимные функции.

Во многих языках есть возможность создавать не именнованные функции, которые используется только в одном месте программы и незаслуживают отдельного названия. В Haskell такая возможно тоже есть. Допустим мы хотим создать функцию, которая складывает возвращает сумму квадратов двух своих аргументов (для того чтобы например, передать её в функцию `zipWith`). Для этого будем использовать следующий синтаксис: `\АРГУМЕНТ_1, АРГУМЕНТ_2, ..., АРГУМЕНТ_N -> ВЫРАЖЕНИЕ`. В данном случае наша функция будет выглядеть так: `\x y -> x^2 + y^2`. Лямбда функции можно использоавать в любом выражении, например в другой лямбда-функции. Вызов функции от аргументов выглядит как обычно: `(\x y -> x^2 + y^2) 2 2 -- это равно 8`. Пример использования:

```Haskell

>> zipWith (\x y -> x^2 + y^2) [1, 2, 3] [10, 20, 30]
[101, 404, 909]


>> map (\x -> (x, x)) [1, 2, 3] -- делаем из каждого элемента пару.
[(1, 1), (2, 2), (3, 3)] 


```

Замечание: символ `\` используется потому, что он наиболее похож на греческий символ "лямбда".

# `case of`

Иногда требуется использовать сопоставление с образцом внутри функций, а не при их определении. Для этого используется конструкция 

``` 
  case ВЫРАЖЕНИЕ of
    ОБРАЗЕЦ_1 -> ВЫРАЖЕНИЕ_1
    ОБРАЗЕЦ_2 -> ВЫРАЖЕНИЕ_2
    ...
    ОБРАЗЕЦ_N -> ВЫРАЖЕНИЕ_N

```

Пример использования:

```Haskell
complexCalculations :: Integer -> [Integer]
complexCalculations n = if n > 0 then [n * 2 + 82] else n : complexCalculation (n - 1)

f :: Integer -> String
f n = case complexCalculation (n + 2) of
  [] -> "Hmmm, the empty list!"
  [1, 2, 3] -> "Probably never happens"
  (x : xs) -> show x ++ show $ length xs


```




