



# [Лекция 2 -- Операторы и типы]


# Операторы.
	
	В Haskell оператор и функция -- почти одно и тоже.
	Оператор -- функция принимающая два аргумента, записываемая в инфиксной форме.

	Можно перейти из одной формы в другую, поставив скобки:



```haskell
	>> 2 + 3
	5

	>> (+) 2 3
	5

	>> (*) 3 4 
	12

	>> (||) False True
	True
```


	Аналогично функции принимающие два аргумента можно превратить в оператор, 
	поставив обратные одинарные кавычки



```haskell
	>> let sumOfSq x y = x^2 + y^2
	>> 2 `sumOfSq` 5
	29
```


## Ассоциативность и приоритеты
	У каждого оператора есть свой приоритет -- число от 1 до 9. Чем выше приоритет, 
	тем раньше выполнится оператор, если не поставлены скобки.

	Приоритеты классических операторов.
	8: ^, **
	7: *, / 
	6: +, -
	4: ==, /=, <, <=, =>, >
	3: &&
	2: ||


	Так же у каждого может быть определена ассоциативность. Левоассоциативные и правоассоциативные
	операторы позволяют записывать без скобок выражения вида a * b * c
	Если оператор * левоассоциативный, то a * b * c = (a * b) * c
	Если оператор * правоассоциативный, то a * b * c = a * (b * c)
 	
 	Пример левоассоциативных операторов: +, -, *, /
 	Пример правоассоциативных операторов: ^, **, &&, ||
 	Пример неассоциативных операторов: ==, /=, <=, >=, <, >



```haskell
	>> 3 ^ 2 ^ 2
	81

	-- 3 ^ 2 ^ 2 ~> 3 ^ (2 ^ 2) ~> 3 ^ 4 ~> 81

	>> 16 / 4 / 2
	2.0

	-- 16 / 4 / 2 ~> (16 / 4) / 2 ~> 4.0 / 2 ~> 2.0

	>> 3 == 3 == 3
	Precedence parsing error
        cannot mix ‘==’ [infix 4] and ‘==’ [infix 4] in the same infix expression
```




## Собственные операторы

В хаскеле можно строить собственные операторы!
Для этого надо придумать его знак, состоящий из символов

! # $ % & * + . / < = > ? @ \\ ^ | - ~   (оператор не должен начинаться с двоеточия),

выбрать его приоритет и указать его ассоциативность

После этого, для левоассоативного оператора надо написать infixl, для правоассоциативного надо написать infixr, а для не ассоциативного надо написать infix. После этого слова надо указать число от 1 до 9 (его приоритет) и наконец написать сам оператор. 
Наконец, после этого надо реализовать сам оператор как обычную функцию (не забыв заключить оператор в скобки.)
Понять схему проще на примере:



```haskell
module Test where

infixl 8 *^*
(*^*) x y = x^2 + y^2

---
>> :l Test
>> 2 *^* 4
20

>> 2 *^* 4 + 2
22

>> 2 *^* 4 *^* 10
500

-- 2 *^* 4 *^* 10 ~> (2 *^* 4) *^* 10 ~>
-- ~> (2^2 + 4^2) *^* 10 ~> (4 + 16) *^* 10 ~>
-- ~> 20 *^* 10 ~> 20^2 + 10^2 ~> 400 + 100 ~>
-- ~> 500


```



# Типы выражений.

	Haskell -- строго типизированный язык и каждое выражение имеет свой тип. 
	Однако haskell умеет самостоятельно выводить тип выражения, если оно составлено правильно.

	Выяснить тип выражения через ghci -- :type (или :t)

##	Базовые типы:


```haskell
	Char, Int, Integer, Float, Double, Bool.
```

	Каждый тип состоит из констант (константы населяют тип).


```haskell
	>> :t 'c' 
	'c' :: Char

	>> :t True 
	True :: Bool

	>> :t 3 
	3 :: Num p => p --- ?!
```

	Num p => называется контекстом. 
	Num -- это класс типов, нужен для того чтобы уметь складывать числа разного типа.

	Строчка 3 :: Num p => p означает, что 3 имеет некоторый неизвестный нам тип 
	(который обозначен буквой p), но такой, что p принадлежит классу типов Num.
	Говорят, что 3 имеет полиморфный тип. 

	Можем уточнить тип числа явным образом:



```haskell
>> let x = 3 :: Integer
>> :t x 
x :: Integer

>> x
3

--
>> let y = 7 :: Double
>> :t y 
y :: Double

>> y
7.0

```


##	Более сложные типы.

	Типы функций:



```haskell
>> :t not
not :: Bool -> Bool


```


	-> обозначает функциональный оператор, у него в качестве аргументов не значения, а типы. 
	Слева от этого оператора показано какой тип функция принимает, а справа -- какой тип возвращает.
	Он **правоассоциативный** (потом поясним на примере что это значит)
	Bool -> Bool означает, что функция not принимает аргумент типа Bool и возвращает значение типа Bool. 
	Посмотрим какой тип имеет функция двух аргументов (&&)


```haskell
>> :t (&&)
(&&) :: Bool -> Bool -> Bool


```


"Выражение" Bool -> Bool -> Bool эквивалентно "выражению"

Bool -> (Bool -> Bool) (так как -> правоассоциативна)

Это значит, что наша функция двух аргументов -- это на самом деле функция одного аргумента, возвращающая функцию еще одного аргумента.

Действительно, попробуем выяснить тип такого (казалось бы некорретного выражения)



```haskell
>> :t (&&) True
(&&) True :: Bool -> Bool

```



Мы получили функцию одного аргумента!
Мало того, можно к ней теперь применить еще аргумент и получить булевское выражение.



```haskell 
>> ((&&) True) False
False


```


Аналогично можно сделать с другими функциями:


```haskell
>> (max 5) 6
6

```


и даже создать выражение имеющее функциональный тип!



```haskell
>> let f = (max 5) -- now f is a function!
>> f 10
10
>> f 2
5

```


Это называется частичным применением функции.

## Сечение операторов.

Для операторов есть синтаксический сахар, дающий возможность "отсекать" один аргумент (сечение оператора). На примере:



```haskell
>> let f = (^3) -- here f a = a^3
>> f 4
64
-- f 4 ~> (^3) 4 ~> 4^3 ~> 64

>> let g = (3^) -- here g a = 3^a
>> g 4
81
-- g 4 ~> (3^) 4 ~> 3^4 ~> 81


```


Единственный оператор, у которого нет правого сечения -- это оператор минус. Выражение (-4) означает число, а не функцию. При этом у минуса есть левое сечение -- (4-) 2 == 2




## Ещё два оператора

Поняв, что такое функциональные типы, мы можем использовать их теперь как аргументы. Т.е. мы можем построить функцию, принимающую функцию как аргумент. Посмотрим на примере:

$ -- это оператор применения аргумента к функции со специальной особенностью. 
Обычное применение аргумента к функции, как мы уже выяснили, имеет левую ассоциативность (т.е. f a b = (f a) b ). Более того -- он имеет самый высокий приоритет -- 10 (которого нет в обычном списке приоритетов).

$ -- это оператор применения функции к аргументу, но он имеет самый низкий приоритет и ПРАВУЮ ассоциативность.

Его тип такой: 



```haskell

infixr 1 $
($) (a -> b) -> a -> b -- first argument is a function, second is a value
($) f a = f a

```




Его можно использовать для последовательных вычислений. Рассмотрим пример:



```haskell

>> floor (max 5 (min 8.9 20) )
8


```



Здесь видно, что есть куча скобочек. Однако используя оператор $ можно этот пример сделать без скобок!



```haskell

>> floor $ max 5 $ min 8.9 20
8

-- floor $ max 5 $ min 8.9 20 ->  		| $ has low priority 
-- floor $ (max 5) $ (min 8.9 20) ~>	
-- floor $ (max 5) $ 8.9 ~> 			| $ is right associative 
-- floor $ ( (max 5) $ 8.9  ) ~>
-- floor $ max 5 8.9 ~>
-- floor $ 8.9 ~>
-- floor 8.9 ~>
-- 8
  

```



Второй оператор -- оператор композиции функций -- .
Он тоже правоассоциативный и имеет приоритет 9. 
Его тип такой:



```haskell

infixr 9 .
(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g x = f (g x)

```



Получается, что этот оператор принимает функцию из b -> c, функцию из a -> b, и строит их композицию -- функцию из a -> c.
Это так же позволяет строить цепочки вычислений:




```haskell

>> floor ( (+ 2) ( (min 5) 4.9))
6
>> floor $ (+ 2) $ (min 5) 4.9
6
>> (floor . (+ 2) . min 5) 4.9
6

```


